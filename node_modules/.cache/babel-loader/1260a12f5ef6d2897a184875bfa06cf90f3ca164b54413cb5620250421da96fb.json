{"ast":null,"code":"// src/index.ts\nimport { useEffect, useRef, useState } from \"react\";\nfunction useIntersectionObserver() {\n  let {\n    threshold = 0,\n    root = null,\n    rootMargin = \"0%\",\n    isEnabled = true,\n    freezeOnceVisible = false,\n    initialIsIntersecting = false,\n    onChange\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!isEnabled) return;\n    if (!ref) return;\n    if (!(\"IntersectionObserver\" in window)) return;\n    if (frozen) return;\n    let unobserve;\n    const observer = new IntersectionObserver(entries => {\n      const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n      entries.forEach(entry => {\n        const isIntersecting = entry.isIntersecting && thresholds.some(threshold2 => entry.intersectionRatio >= threshold2);\n        setState({\n          isIntersecting,\n          entry\n        });\n        if (callbackRef.current) {\n          callbackRef.current(isIntersecting, entry);\n        }\n        if (isIntersecting && freezeOnceVisible && unobserve) {\n          unobserve();\n          unobserve = void 0;\n        }\n      });\n    }, {\n      threshold,\n      root,\n      rootMargin\n    });\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref, isEnabled, JSON.stringify(threshold), root, rootMargin, frozen, freezeOnceVisible]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({\n        isIntersecting: initialIsIntersecting,\n        entry: void 0\n      });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [setRef, !!state.isIntersecting, state.entry];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport { useIntersectionObserver };","map":{"version":3,"names":["useEffect","useRef","useState","useIntersectionObserver","threshold","root","rootMargin","isEnabled","freezeOnceVisible","initialIsIntersecting","onChange","arguments","length","undefined","_a","ref","setRef","state","setState","isIntersecting","entry","callbackRef","current","frozen","window","unobserve","observer","IntersectionObserver","entries","thresholds","Array","isArray","forEach","some","threshold2","intersectionRatio","observe","disconnect","JSON","stringify","prevRef","_a2","target","result"],"sources":["/opt/dev/star_share/web/node_modules/.pnpm/@heroui+use-intersection-observer@2.2.14_react@19.1.0/node_modules/@heroui/use-intersection-observer/dist/index.mjs"],"sourcesContent":["// src/index.ts\nimport { useEffect, useRef, useState } from \"react\";\nfunction useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  isEnabled = true,\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange\n} = {}) {\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!isEnabled) return;\n    if (!ref) return;\n    if (!(\"IntersectionObserver\" in window)) return;\n    if (frozen) return;\n    let unobserve;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n        entries.forEach((entry) => {\n          const isIntersecting = entry.isIntersecting && thresholds.some((threshold2) => entry.intersectionRatio >= threshold2);\n          setState({ isIntersecting, entry });\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = void 0;\n          }\n        });\n      },\n      { threshold, root, rootMargin }\n    );\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref, isEnabled, JSON.stringify(threshold), root, rootMargin, frozen, freezeOnceVisible]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: void 0 });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [setRef, !!state.isIntersecting, state.entry];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport {\n  useIntersectionObserver\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}